const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const cors = require('cors');
const path = require('path');
const logger = require('../utils/logger'); // Assuming a logger utility will be created

const PORT = process.env.PORT || 3001;

// Initialiser l'application Express
const app = express();

// Cr√©er le serveur HTTP
const server = http.createServer(app);

// Configuration CORS plus permissive
const corsOptions = {
  origin: ['http://localhost:3000', 'http://127.0.0.1:3000'],
  methods: ['GET', 'POST', 'OPTIONS', 'PATCH'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true
};

app.use(cors(corsOptions));

// Middleware pour parser le JSON
app.use(express.json());

// Servir l'interface web de d√©mo
app.get('/demo', (req, res) => {
  res.sendFile(path.join(__dirname, '..', 'demo_web_interface.html'));
});

// Servir la nouvelle interface d√©mo moderne
app.get('/demo-modern', (req, res) => {
  res.sendFile(path.join(__dirname, '..', 'demo_web_interface_modern.html'));
});

// Endpoint API pour simuler des messages (pour l'interface web)
app.post('/api/simulate-message', async (req, res) => {
  try {
    const { message } = req.body;
    
    if (!message || typeof message !== 'string') {
      return res.status(400).json({ error: 'Message requis' });
    }
    
    logger.info(`[API] üì® Simulation de message re√ßue: "${message}"`);
    
    // Importer dynamiquement le simulateur pour √©viter les d√©pendances circulaires
    const { simulateIncomingMessage } = require('../simulate_conversation');
    
    // Simuler le message entrant
    await simulateIncomingMessage(message);
    
    res.json({ 
      success: true, 
      message: 'Message simul√© avec succ√®s',
      sentMessage: message
    });
    
  } catch (error) {
    logger.error('[API] ‚ùå Erreur simulation message:', error);
    res.status(500).json({ 
      error: 'Erreur lors de la simulation du message',
      details: error.message 
    });
  }
});

// Endpoint pour r√©cup√©rer l'√©tat de la conversation de d√©mo
app.get('/api/demo-conversation-state', async (req, res) => {
  try {
    const { supabase } = require('../services/database');
    const { normalizePhoneNumber } = require('../utils/phoneNumber');
    
    const demoPhoneNumber = normalizePhoneNumber('demo+33123456789@c.us');
    
    logger.info(`[API] üìä R√©cup√©ration √©tat conversation d√©mo: ${demoPhoneNumber}`);
    
    // Chercher la conversation de d√©mo
    const { data: conversations, error } = await supabase
      .from('conversations')
      .select('id, phone_number, state, detected_price, vehicle_id, created_at, last_message_at')
      .eq('phone_number', demoPhoneNumber)
      .limit(1);
    
    if (error) {
      logger.error('[API] ‚ùå Erreur r√©cup√©ration conversation d√©mo:', error);
      return res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration de la conversation' });
    }
    
    if (!conversations || conversations.length === 0) {
      return res.json({
        exists: false,
        state: null,
        detectedPrice: null,
        message: 'Conversation de d√©mo non trouv√©e'
      });
    }
    
    const conversation = conversations[0];
    
    res.json({
      exists: true,
      conversationId: conversation.id,
      state: conversation.state,
      detectedPrice: conversation.detected_price,
      vehicleId: conversation.vehicle_id,
      createdAt: conversation.created_at,
      lastMessageAt: conversation.last_message_at
    });
    
  } catch (error) {
    logger.error('[API] ‚ùå Exception r√©cup√©ration √©tat d√©mo:', error);
    res.status(500).json({ 
      error: 'Erreur serveur lors de la r√©cup√©ration de l\'√©tat',
      details: error.message 
    });
  }
});

// Endpoint pour modifier l'√©tat de la conversation de d√©mo
app.patch('/api/demo-conversation-state', async (req, res) => {
  try {
    const { newState } = req.body;
    
    if (!newState || typeof newState !== 'string') {
      return res.status(400).json({ error: 'Nouvel √©tat requis' });
    }
    
    // Valider l'√©tat
    const validStates = ['active', 'negotiation', 'completed', 'archived'];
    if (!validStates.includes(newState)) {
      return res.status(400).json({ 
        error: '√âtat invalide', 
        validStates: validStates 
      });
    }
    
    const { supabase } = require('../services/database');
    const { normalizePhoneNumber } = require('../utils/phoneNumber');
    
    const demoPhoneNumber = normalizePhoneNumber('demo+33123456789@c.us');
    
    logger.info(`[API] üîÑ Changement √©tat conversation d√©mo: ${demoPhoneNumber} -> ${newState}`);
    
    // Mettre √† jour l'√©tat de la conversation de d√©mo
    const { data, error } = await supabase
      .from('conversations')
      .update({
        state: newState,
        last_state_change: new Date().toISOString(),
        state_change_reason: 'Manuel via interface d√©mo'
      })
      .eq('phone_number', demoPhoneNumber)
      .select()
      .single();
    
    if (error) {
      logger.error('[API] ‚ùå Erreur mise √† jour √©tat d√©mo:', error);
      return res.status(500).json({ error: 'Erreur lors de la mise √† jour de l\'√©tat' });
    }
    
    if (!data) {
      return res.status(404).json({ error: 'Conversation de d√©mo non trouv√©e' });
    }
    
    logger.info(`[API] ‚úÖ √âtat conversation d√©mo mis √† jour: ${newState}`);
    
    res.json({
      success: true,
      conversationId: data.id,
      previousState: data.state,
      newState: newState,
      updatedAt: data.last_state_change
    });
    
  } catch (error) {
    logger.error('[API] ‚ùå Exception mise √† jour √©tat d√©mo:', error);
    res.status(500).json({ 
      error: 'Erreur serveur lors de la mise √† jour de l\'√©tat',
      details: error.message 
    });
  }
});

// Endpoint pour reset complet de la conversation de d√©mo
app.delete('/api/demo-conversation-reset', async (req, res) => {
  try {
    const { supabase } = require('../services/database');
    const { normalizePhoneNumber } = require('../utils/phoneNumber');
    
    const demoPhoneNumber = normalizePhoneNumber('demo+33123456789@c.us');
    
    logger.info(`[API] üîÑ Reset complet conversation d√©mo: ${demoPhoneNumber}`);
    
    // 1. R√©cup√©rer l'ID de la conversation de d√©mo
    const { data: conversation, error: convError } = await supabase
      .from('conversations')
      .select('id')
      .eq('phone_number', demoPhoneNumber)
      .single();
    
    if (convError && convError.code !== 'PGRST116') { // PGRST116 = pas trouv√©
      logger.error('[API] ‚ùå Erreur r√©cup√©ration conversation d√©mo:', convError);
      return res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration de la conversation' });
    }
    
    if (!conversation) {
      return res.json({
        success: true,
        message: 'Aucune conversation de d√©mo √† reset',
        deleted: {
          conversation: false,
          messages: 0,
          priceOffers: 0
        }
      });
    }
    
    const conversationId = conversation.id;
    let deletedMessages = 0;
    let deletedPriceOffers = 0;
    
    // 2. Supprimer les offres de prix li√©es
    const { data: deletedOffers, error: offersError } = await supabase
      .from('price_offers')
      .delete()
      .eq('conversation_id', conversationId)
      .select('id');
    
    if (offersError) {
      logger.error('[API] ‚ùå Erreur suppression offres prix:', offersError);
    } else {
      deletedPriceOffers = deletedOffers?.length || 0;
      logger.info(`[API] üóëÔ∏è ${deletedPriceOffers} offres de prix supprim√©es`);
    }
    
    // 3. Supprimer tous les messages de la conversation
    const { data: deletedMsgs, error: messagesError } = await supabase
      .from('messages')
      .delete()
      .eq('conversation_id', conversationId)
      .select('id');
    
    if (messagesError) {
      logger.error('[API] ‚ùå Erreur suppression messages:', messagesError);
    } else {
      deletedMessages = deletedMsgs?.length || 0;
      logger.info(`[API] üóëÔ∏è ${deletedMessages} messages supprim√©s`);
    }
    
    // 4. Reset la conversation (garder la conversation mais reset les donn√©es)
    const { error: resetError } = await supabase
      .from('conversations')
      .update({
        state: 'active',
        last_message_at: new Date().toISOString(),
        last_state_change: new Date().toISOString(),
        state_change_reason: 'Reset d√©mo',
        detected_price: null,
        price_detected_at: null,
        price_detected_message_id: null
      })
      .eq('id', conversationId);
    
    if (resetError) {
      logger.error('[API] ‚ùå Erreur reset conversation:', resetError);
      return res.status(500).json({ error: 'Erreur lors du reset de la conversation' });
    }
    
    logger.info(`[API] ‚úÖ Conversation d√©mo reset√©e: ${deletedMessages} messages, ${deletedPriceOffers} offres supprim√©es`);
    
    res.json({
      success: true,
      message: 'Conversation de d√©mo reset√©e avec succ√®s',
      deleted: {
        conversation: true,
        messages: deletedMessages,
        priceOffers: deletedPriceOffers
      },
      resetAt: new Date().toISOString()
    });
    
  } catch (error) {
    logger.error('[API] ‚ùå Exception reset d√©mo:', error);
    res.status(500).json({ 
      error: 'Erreur serveur lors du reset',
      details: error.message 
    });
  }
});

// Initialiser Socket.IO avec la m√™me configuration CORS
const io = new Server(server, {
  cors: corsOptions,
  transports: ['websocket', 'polling'],
  pingTimeout: 60000,
  pingInterval: 25000
});

// Configuration des WebSockets
io.on('connection', (socket) => {
  logger.info('Nouvelle connexion WebSocket √©tablie:', socket.id);

  // Envoyer un message de bienvenue
  socket.emit('welcome', { message: 'Connexion WebSocket √©tablie avec succ√®s' });

  // Handler pour les messages de test
  socket.on('test_new_message', (message) => {
    logger.info('üì§ Message de test re√ßu, rediffusion √† tous les clients...');
    logger.info('üì§ Message:', JSON.stringify(message, null, 2));
    
    // Rediffuser le message √† tous les clients connect√©s
    io.emit('new_message', message);
    
    logger.info('‚úÖ Message de test rediffus√© avec succ√®s!');
  });

  // G√©rer la d√©connexion
  socket.on('disconnect', () => {
    logger.info('Client d√©connect√©:', socket.id);
  });

  // G√©rer les erreurs
  socket.on('error', (error) => {
    logger.error('Erreur WebSocket:', error);
  });
});

module.exports = {
  app,
  server,
  io,
  PORT,
};
